#!/usr/bin/perl -w

use strict;
use warnings;
use POSIX;
use File::Pid;
use XML::FeedPP;
use LWP::UserAgent;
use HTML::Entities;
use URI::Escape;
use HTML::WikiConverter;
use List::MoreUtils qw(any);
use Digest::MD5 qw(md5 md5_hex md5_base64);
use Config::Tiny;


# daemon stuff
my $daemonName      = "diaspora-rss";
my $dieNow          = 0;                                     # used for "infinte loop" construct - allows daemon mode to gracefully exit
my $sleep           = 300;                                   # number of seconds to wait between "do something" execution after queue is clear
my $pidFilePath     = "/var/run/";                           # PID file path
my $logFilePath     = "/var/log/";
my $cacheFilePath   = "/var/cache/".$daemonName."/";
my $configFilePath  = "/etc/".$daemonName."/";
my $pidFile         = $pidFilePath.$daemonName.".pid";
my $logFile         = $logFilePath.$daemonName.".log";
my $configFile      = $configFilePath.$daemonName.".conf";
my $cacheFile       = $cacheFilePath.$daemonName.".cache";

# Diaspora/RSS interface stuff
my $ua          = LWP::UserAgent->new( keep_alive => 1 );
my $wc          = new HTML::WikiConverter( dialect => 'Diaspora' ); # HTML -> D* markup converter
my $config      = Config::Tiny->read( $configFile );

# rss bot parameter
my $pod         = $config->{main}->{pod};
my $username    = $config->{main}->{username};
my $passwd      = $config->{main}->{password};


###############################################################################
### DEAMON STUB
###############################################################################
use POSIX qw(setsid);
chdir '/';
umask 0;
open STDIN,  '/dev/null'   or die "Can't read /dev/null: $!";
open STDOUT, '>>'.$logFile or die "Can't write to logfile: $!";
open STDERR, '>>'.$logFile or die "Can't write to logfile: $!";
defined( my $pid = fork ) or die "Can't fork: $!";
exit if $pid;

# dissociate this process from the controlling terminal that started it and stop being part
# of whatever process group this process was a part of.
POSIX::setsid() or die "Can't start a new session.";

# callback signal handler for signals.
$SIG{INT} = $SIG{TERM} = $SIG{HUP} = \&signalHandler;
$SIG{PIPE} = 'ignore';

# create pid file in /var/run/
my $pidfile = File::Pid->new( { file => $pidFile, } );

$pidfile->write or die "Can't write PID file: $!";


###############################################################################
### DEAMON
###############################################################################

# Enable cookies
$ua->cookie_jar({});  

until( $dieNow )
{
  eval
  { # try
    my %feedcache;
    my $guidcache = Config::Tiny->read( $cacheFile );
    
    $config = Config::Tiny->read( $configFile );  # Reread config every iteration in order to incorporate new feeds
    logEntry("Diaspora* RSS BOT - STARTED");
    my $auth_token = loginDiaspora();

    if( $auth_token ne "" )
    {
      # Query all feeds and build up feedcache
      foreach my $key ( keys %{$config->{feeds}} )
      {
        eval
        { # try
          my $url = $config->{feeds}->{$key};
          my $feed = XML::FeedPP->new( $url );

          foreach my $item ( $feed->get_item() )
          {
            my $digest = md5_hex( $item->title(), $item->description() );
            $feedcache{$digest}{feed} = $url;
            $feedcache{$digest}{item} = $item;
            push @{ $feedcache{$digest}{tags} }, getHashtagFromUrl( $url );
          }
          1;
        }
        or do
        {
          logEntry( "ERROR: ".$@." -> Processing next item" );
          next;
        }
      }
      
      # Iterate all feeds and only post new items
      my @old_items = values %{$guidcache->{guids}};

      foreach my $guid ( keys %feedcache )
      {
        unless( any { $_ eq $guid } @old_items )
        {
          my $tags = "";
          foreach my $tag ( @{ $feedcache{$guid}{tags} } )
          {
            $tags = $tags.$tag." ";
          }
          $tags = $tags."#rss-all";
          
          logEntry( "NEW ITEM [".$feedcache{$guid}{feed}." -> \"".$feedcache{$guid}{item}->title()."\" tags:".$tags."]" );
          postItem( $auth_token, $feedcache{$guid}{item}, $tags );
        }
      }

      # Delete old digests
      for( keys %{$guidcache->{guids}} )
      {
        delete $guidcache->{guids}->{$_};
      }

      # Insert new digests
      my $i = '0';    
      my @new_items = keys( %feedcache );
      foreach my $item (@new_items)
      {
        $guidcache->{guids}->{$i++} = $item;
      }
      $guidcache->write( $cacheFile );
      $config->write( $configFile );
      logoutDiaspora();
    }
    logEntry("Diaspora* RSS BOT - STOPPED");  
    1;  # Return true statement
  }
  or do
  { # catch
    logEntry( "ERROR: ".$@ );
  };

  # Sleep until next update
  sleep( $sleep );
}  

# catch signals and end the program if one is caught.
sub signalHandler
{
 $dieNow = 1;    # this will cause the "infinite loop" to exit
}

# do this stuff when exit() is called.
END
{
  $pidfile->remove if defined $pidfile;
}


###############################################################################
### Logging
###############################################################################
sub logEntry
{
  my ($logText) = @_;
  my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) = localtime(time);
  my $dateTime = sprintf "%4d-%02d-%02d %02d:%02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min, $sec;
  print "$dateTime $logText\n";
}


###############################################################################
### Diaspora* RSS BOT
###############################################################################
sub loginDiaspora
{
  my $csrf_param;
  my $csrf_token;
  
  my $sign_in_page = $ua->get( $pod.'/users/sign_in' )->decoded_content();

  $sign_in_page =~ m/"csrf-param" content="([^"]+)"/ or return "";  $csrf_param = decode_entities($1);
  $sign_in_page =~ m/"csrf-token" content="([^"]+)"/ or return "";  $csrf_token = decode_entities($1);

  my $request = HTTP::Request->new( 'POST', $pod.'/users/sign_in' );
  $request->header( 'Connection' => 'keep-alive' );
  $request->header( 'Content-Type' => 'application/x-www-form-urlencoded' );
  $request->content( 'utf8=%E2%9C%93&'.uri_escape($csrf_param).'='.uri_escape($csrf_token).'&user%5Busername%5D='.$username.'&user%5Bpassword%5D='.$passwd.'&user%5Bremember_me%5D=0&commit=Anmelden' );
  $ua->request( $request );
  return $csrf_token;
}

sub logoutDiaspora
{
  my $request = HTTP::Request->new( 'GET', $pod.'/users/sign_out' );
  $request->header( 'Connection' => 'keep-alive' );
  $ua->request( $request );  
}

sub postItem
{
  my ($token, $item, $tags) = @_;
  my $markup = $wc->html2wiki( html => $item->description() );
  my $message = "### [".escapeString( escapeMarkup( $item->title() ) )."](".escapeString( $item->link() ).")\\r\\n".escapeString( $tags )."\\r\\n\\r\\n".escapeString( $markup );
  
  my $json_message = '{"status_message":{"text":"'.$message.'"},"aspect_ids":"public"}';
  my $request = HTTP::Request->new( 'POST', $pod.'/status_messages' );
  $request->header( 'Content-Type' => 'application/json; charset=UTF-8' );
  $request->header( 'Connection' => 'keep-alive' );
  $request->header( 'X-CSRF-Token' => $token );
  $request->content( $json_message );
  $ua->request( $request );
}

sub escapeString
{
  my ($string) = @_;
  $string =~ s/\\/\\\\/g; # Replace '\' with '\\'
  $string =~ s/\"/\\\"/g; # Replace '"' with '\"'
  return $string;
}

sub escapeMarkup
{
  my( $string ) = @_;
  $string =~ s/^#/&#35;/g;        # Escape "#" -> "&#35;" (at beginning)
  $string =~ s/([^&])#/$1&#35;/g; # Escape "#" -> "&#35;"
  return $string;
}

sub getHashtagFromUrl
{
  my ($url) = @_;
  
  for($url)
  {
    s/https?:\/\/(.*)\/?$/$1/g; # Cut off protocol
    s/\/$//;  # Cut off possible trailing /
    s/[^a-zA-Z0-9_]/-/g;  # Replace special chars with '-'
  }
  return "#rss-".$url;
}




